'''
nowcode-约瑟夫问题I.py
https://www.nowcoder.com/practice/11b018d042444d4d9ca4914c7b84a968?tpId=8&&tqId=11044&rp=1&ru=/activity/oj&qru=/ta/cracking-the-coding-interview/question-ranking


题目描述
约瑟夫问题是一个非常著名的趣题，即由n个人坐成一圈，按顺时针由1开始给他们编号。然后由第一个人开始报数，数到m的人出局。现在需要求的是最后一个出局的人的编号。

给定两个int n和m，代表游戏的人数。请返回最后一个出局的人的编号。保证n和m小于等于1000。

测试样例：
5 3
返回：4
'''

# -*- coding:utf-8 -*-
class Joseph:
    def getResult(self, n, m):
        # write code here
        '''
        思路一：定义链表模拟过程，一直向前找next节点，删除报数报到m的节点
        思路二：定义数组模拟过程，弹出一个数后，以这个数的位置截断数组，交替左右两部分形成新数组
        '''
        '''
        思路三：递推公式，寻找子问题，用递归或动态规划求解
        f(n,k,seq_F) 返回值为：            
            【在从0开始的坐标体系下，
            在序列seq_F前n个人围成的圈中，进行约瑟夫报数淘汰游戏，
            最终活下来的人的编号（编号也是从0开始）】
            
        #---------------
        初始： f(n, k, seq_F)
            n表示 序列seq_F中 前n个人围成一圈；
            k表示 从0开始报数，报数到k的人淘汰；
            初始序列 seq_F=[0,1,2, ... , k-1, k, k+1, ... , n-1] 
        #---------------
        
        现在开始第一轮报数， 
            编号为 【k】 的那个人淘汰（编号从0开始）；
            此时序列变为：
            [0,1,2, ... , k-1,     k+1, ... , n-1]；
        #现在考虑下一轮报数，下一轮第一个报数的是 编号为 【k+1】的那个人；
            还是报数报到 k 的人被淘汰；
            所以也就相当于在新序列 
            [k+1, ... , n-1, 0,1,2, ... , k-1] 中，
            重复做第一轮的操作；
            
        这就化为一个子问题：
        现在令刚才的新序列 [k+1, ... , n-1, 0,1,2, ... , k-1] 为 seq_G
        则：
            f(n, k, seq_F) = f(n-1, k, seq_G)
                其中 f(n, k, seq_F) 表示
                【在从0开始的坐标体系下，
                在序列seq_F前n个人围成的圈中，进行约瑟夫报数淘汰游戏，
                最终活下来的人的编号（编号也是从0开始）】；
                
                f(n-1, k, seq_G) 表示
                【在从0开始的坐标体系下，
                在序列 seq_G 前n-1个人围成的圈中，进行约瑟夫报数淘汰游戏，
                最终活下来的人的编号（编号也是从0开始）】；
        
        由于子问题中seq_F seq_G 序列并不相同，不算完全的子问题，不好递归或动态规划操作；
        现在我们寻找 seq_F seq_G 之间的关系；
        举例：
            取 n=8 , k=2, seq_F = [0,1,2,3,4,5,6,7]；
            f(n=8, k=2, seq_F=[0,1,2,3,4,5,6,7])
            
            第一轮淘汰 编号为k的人,也就是数组坐标为 2 的那个人 ，得到序列
            [0,1,  3,4,5,6,7]
            然后进入下一轮报数,也就相当于在序列
            [3,4,5,6,7,  0,1] 中重复第一轮的操作
            令 seq_G = [3,4,5,6,7,  0,1];
            即：
                f(n=8, k=2, seq_F=[0,1,2,3,4,5,6,7]) 
                = 
                f(n=8-1, k=2, seq_G=[3,4,5,6,7,  0,1])
            ;
            对于序列 seq_G=[3,4,5,6,7,  0,1]；为了能被序列 seq_F 表示；我们尝试将序列 seq_G 转换为从0开始的序列seq_F'，（这里seq_F' 只取前n-1个出来讨论，比第一轮少一个），
            观察 seq_G=[3,4,5,6,7,0,1]
                 seq_F'=[0,1,2,3,4,5,6];
              能得到如下关系： seq_G[i] = (seq_F'[i] + k + 1) % n; 其中n=len(seq_F) 上一轮的长度；
            这里的 n=len(seq_F)=8 ； k=2；
            i=0; seq_G[i] = 3 = (0 + 2 + 1) % 8 = 3
            i=1; seq_G[i] = 4 = (2 + 2 + 1) % 8 = 4
            ...
            i=4; seq_G[i] = 7 = (4 + 2 + 1) % 8 = 7
            i=5; seq_G[i] = 0 = (5 + 2 + 1) % 8 = 7
            ...
            完全正确；
            上述递推式：
                f(n=8, k=2, seq_F=[0,1,2,3,4,5,6,7]) 
                = 
                f(n=8-1, k=2, seq_G=[3,4,5,6,7,  0,1])
            将【seq_G[i] = (seq_F'[i] + k + 1) % n 】带入，替换为一般化的变量表示，得：
                f(n=n, k=k, seq_F=[0, 1, 2, ... , k-1, k, k+1, ..., n-1]) 
                = 
                f(n=n-1, k=k, (seq_F[i] + k + 1) % n)
            
            由于通式中第三个参数【(seq_F[i] + k + 1) % n】是一种映射操作，相当于对数组坐标系进行了变换，并没有本质的修改什么；所以可将这个【坐标映射】操作放到外面来；得到：
                f(n=n, k=k, seq_F=[0, 1, 2, ... , k-1, k, k+1, ..., n-1]) 
                = 
                (  f(n=n-1,k=k,seq_F[i] ) +k+1  ) % n
            
            此时可看出参数 k，seq_F 始终不变，则可再简化为： 
                f(n) = ( f(n-1) +k+1 ) % n if n>1 else 0
            递归代码如下：
        '''
        def f(n):
            return ( f(n-1) +k+1 ) % n if n>1 else 0
        
        #牛客网的题目要求 seq编号从1开始，k从1开始，所以 k需要减一；最终结果加一
        k=m-1
        return f(n)+1 
        '''
        参考 思路三：递推公式
        参考题解：https://blog.csdn.net/OKasy/article/details/79503398
        递推式：注意人的编号从1 开始，报数也从1 开始
        f(1,m)=0; (i==1)
        f(i,m)=(f(i-1,m)+m)%i ; (i>1)
        
        f(i,m)的返回结果表示 剩余i个人的时候，以m为报数的最大值，最后弹出的人的编号（编号从0 开始到i结束的连续）
        f(1,m) 表示只剩下一个人的时候，弹出的人的编号为1，
        设m=3，表示从1 开始报数，报到3弹出
        f(2) = (f(2-1) + m) % 2 = （ 0 + 3 ）% 2 == 1
        例如：
        n=2个人 [0,1]#编号从0 开始
        m=3 报数到3 则弹出
        现在求 f(n=2, m=3)，即n=2，m=3时，最后弹出的人的编号，
        f(2,3) = (f(1,3) + 3 )% 2 = （ 0 + 3 ）% 2 == 1
        【0,1】 第一次弹出【0】，剩下【1】第二次弹出【1】，即答案为1
        
        
        '''
        #返回弹出者的编号，从0开始到i结束，0到i之间没有间隔；题目要求为从1 开始计数
        #def f(n,m):
        #    if n==1:
        #        return 0
        #    return (f(n-1,m)+m)%n
        #return f(n,m)+1
        
        #
            
        '''
        思路二：模拟这个过程
        
        #玩家从1开始到n编号，报数也从1开始到k，循环
        模拟这个过程，每次踢掉一个人后，将数组【A,m,B】切分为两部分【A】和【B】，交换位置变为【B,A】;直到数组长度为1
        
        players = list(range(1,n+1))
        while len(players)>1:
            
            #n=6, [1,2,3,4,5,6] m=6时，m%n == 0应该去掉第六个元素，所以idx=len(players)-1
            
            eliminated_idx = len(players)-1 if m%len(players) == 0 else m%len(players)-1 
            #print("eliminated_idx=",eliminated_idx,players[eliminated_idx],"=",players)
            players = players[eliminated_idx+1:] + players[:eliminated_idx]
        return players[0]
        '''
        